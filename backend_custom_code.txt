=== backend/products/services.py ===
# backend/products/services.py

import os
import torch
from torch.serialization import add_safe_globals
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from datetime import datetime, timedelta
from django.db.models import Sum, Avg
from .ml_models import ProductRecommender
from .models import Product, UserBehavior, ProductView, RecommendationLog, ProductFavorite
from accounts.models import UserProfile
from django.contrib.auth.models import User

# 안전한 타입들 등록
add_safe_globals([
    MinMaxScaler,
    dict,
    np.ndarray,
    torch.nn.Parameter,
    torch._utils._rebuild_tensor_v2
])

class RecommendationService:
    def __init__(self, user):
        self.user = user
        self.model = None
        self.user_to_idx = {}
        self.product_to_idx = {}
        self.scaler = None
        self._load_model()
        
    def _load_model(self):
        """모델과 관련 데이터 로드"""
        try:
            device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
            model_path = 'model_weights.pth'
            
            # 모델 초기화
            self.model = ProductRecommender(
                n_users=User.objects.count(),
                n_products=Product.objects.count()
            )

            if os.path.exists(model_path):
                try:
                    # 모델 가중치 로드
                    checkpoint = torch.load(
                        model_path,
                        map_location=device
                    )
                    self.model.load_state_dict(checkpoint['model_state_dict'])
                    self.model.to(device)
                    self.model.eval()

                    # 메타데이터 로드
                    if os.path.exists('model_metadata.pth'):
                        metadata = torch.load('model_metadata.pth', map_location=device)
                        self.user_to_idx = metadata.get('user_to_idx', {})
                        self.product_to_idx = metadata.get('product_to_idx', {})
                        
                        # MinMaxScaler 상태 복원
                        self.scaler = MinMaxScaler()
                        if 'scaler_params' in metadata:
                            scaler_state = metadata['scaler_params']
                            self.scaler.min_ = scaler_state['min_']
                            self.scaler.scale_ = scaler_state['scale_']
                            self.scaler.data_min_ = scaler_state.get('data_min_')
                            self.scaler.data_max_ = scaler_state.get('data_max_')
                            self.scaler.data_range_ = scaler_state.get('data_range_')
                    else:
                        self.scaler = MinMaxScaler()
                    
                except Exception as e:
                    print(f"Error during model loading: {e}")
                    self.scaler = MinMaxScaler()
            else:
                print("Model weights file not found, using defaults")
                self.model.to(device)
                self.model.eval()
                self.scaler = MinMaxScaler()
                
        except Exception as e:
            print(f"Error in model loading: {e}")
            self.scaler = MinMaxScaler()
            if self.model:
                self.model.to(device)
                self.model.eval()

    def predict_user_interest(self, product_id):
        try:
            device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
            
            # 사용자와 상품 인덱스 가져오기
            user_idx = self.user_to_idx.get(self.user.id, 0)
            product_idx = self.product_to_idx.get(product_id, 0)
            
            # 사용자 행동 데이터 가져오기
            behavior = UserBehavior.objects.filter(
                user=self.user,
                product_id=product_id
            ).first()
            
            if behavior:
                behavior_data = [
                    behavior.click_count,
                    behavior.view_duration,
                    behavior.cart_add_count
                ]
            else:
                behavior_data = [0, 0, 0]
                
            # numpy 배열로 변환 후 tensor로 변환
            behavior_data_array = np.array([behavior_data])
            behavior_tensor = torch.from_numpy(behavior_data_array).float().to(device)
            
            if self.scaler:
                behavior_tensor = torch.from_numpy(
                    self.scaler.transform(behavior_data_array)
                ).float().to(device)
                
            # 사용자 특성 가져오기
            user_profile = self.user.userprofile
            gender_enc = [0, 0, 0]
            gender_enc[['M', 'F', 'O'].index(user_profile.gender)] = 1
            
            age_enc = [0, 0, 0, 0, 0]
            age_enc[['10', '20', '30', '40', '50'].index(user_profile.age_group)] = 1
            
            income_enc = [0, 0, 0]
            income_enc[['L', 'M', 'H'].index(user_profile.income_level)] = 1
            
            user_features = gender_enc + age_enc + income_enc
            user_features_tensor = torch.tensor([user_features]).float().to(device)
            
            # 모델에 입력하여 예측
            with torch.no_grad():
                user_ids = torch.tensor([user_idx]).to(device)
                product_ids = torch.tensor([product_idx]).to(device)
                prediction = self.model(
                    user_ids, 
                    product_ids, 
                    user_features_tensor, 
                    behavior_tensor
                )
                
            return prediction.item()
            
        except Exception as e:
            print(f"예측 중 오류 발생: {e}")
            return 0.0
        
    def load_model(self):
        model = ProductRecommender(
            n_users=User.objects.count(),
            n_products=Product.objects.count()
        )
        try:
            device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
            model_path = 'model_weights.pth'
            
            if os.path.exists(model_path):
                try:
                    # 안전하게 모델 로드
                    checkpoint = torch.load(
                        model_path,
                        map_location=device,
                        weights_only=True  # 가중치만 로드
                    )
                    
                    model.load_state_dict(checkpoint['model_state_dict'])
                    model.to(device)
                    model.eval()

                    # 메타데이터는 별도 파일에서 로드
                    if os.path.exists('model_metadata.pth'):
                        metadata = torch.load('model_metadata.pth', map_location=device)
                        user_to_idx = metadata.get('user_to_idx', {})
                        product_to_idx = metadata.get('product_to_idx', {})
                        
                        # MinMaxScaler 상태 복원
                        scaler = MinMaxScaler()
                        if 'scaler_params' in metadata:
                            scaler_state = metadata['scaler_params']
                            scaler.min_ = scaler_state['min_']
                            scaler.scale_ = scaler_state['scale_']
                            scaler.data_min_ = scaler_state.get('data_min_')
                            scaler.data_max_ = scaler_state.get('data_max_')
                            scaler.data_range_ = scaler_state.get('data_range_')
                    else:
                        user_to_idx = {}
                        product_to_idx = {}
                        scaler = MinMaxScaler()
                    
                    print("Model and metadata loaded successfully")
                    
                except Exception as e:
                    print(f"Error during model loading: {e}")
                    user_to_idx = {}
                    product_to_idx = {}
                    scaler = MinMaxScaler()
            else:
                print("Model weights file not found, using defaults")
                user_to_idx = {}
                product_to_idx = {}
                scaler = MinMaxScaler()
                model.to(device)
                model.eval()
                
        except Exception as e:
            print(f"Error in model loading: {e}")
            user_to_idx = {}
            product_to_idx = {}
            scaler = MinMaxScaler()
            model.to(device)
            model.eval()
            
        return model, user_to_idx, product_to_idx, scaler

    def get_recommendations(self, limit=8):
        """사용자 맞춤 상품 추천"""
        try:
            # 모든 상품 가져오기
            all_products = Product.objects.all()
            predictions = []

            # 각 상품에 대한 사용자 관심도 예측
            for product in all_products:
                try:
                    score = self.predict_user_interest(product.id)
                    predictions.append((product, score))
                except Exception as e:
                    print(f"Error predicting interest for product {product.id}: {str(e)}")
                    continue

            # 점수 기준 내림차순 정렬
            predictions.sort(key=lambda x: x[1], reverse=True)
            
            # 상위 N개 상품 반환
            recommended_products = [pred[0] for pred in predictions[:limit]]
            return recommended_products

        except Exception as e:
            print(f"Error in get_recommendations: {str(e)}")
            # 에러 발생시 조회수 기준으로 상품 반환
            return Product.objects.all().order_by('-total_views')[:limit]
        
    def predict_user_interest(self, product_id):
        """특정 상품에 대한 사용자의 관심도 예측"""
        try:
            # 필요한 인덱스 가져오기
            user_idx = self.user_to_idx.get(self.user.id, 0)
            product_idx = self.product_to_idx.get(product_id, 0)

            # 사용자 프로필 데이터 준비
            user_profile = self.user.userprofile
            
            # 성별 원-핫 인코딩
            gender_enc = [0, 0, 0]  # [M, F, O]
            gender_map = {'M': 0, 'F': 1, 'O': 2}
            gender_enc[gender_map.get(user_profile.gender, 2)] = 1

            # 연령대 원-핫 인코딩
            age_enc = [0, 0, 0, 0, 0]  # [10, 20, 30, 40, 50]
            age_map = {'10': 0, '20': 1, '30': 2, '40': 3, '50': 4}
            age_enc[age_map.get(user_profile.age_group, 1)] = 1

            # 소득수준 원-핫 인코딩
            income_enc = [0, 0, 0]  # [L, M, H]
            income_map = {'L': 0, 'M': 1, 'H': 2}
            income_enc[income_map.get(user_profile.income_level, 1)] = 1

            # 행동 데이터 가져오기
            behavior = UserBehavior.objects.filter(
                user=self.user,
                product_id=product_id
            ).first()

            if behavior:
                behavior_data = [
                    behavior.click_count,
                    behavior.view_duration,
                    behavior.cart_add_count
                ]
            else:
                behavior_data = [0, 0, 0]

            # 행동 데이터 정규화
            behavior_data = self.scaler.transform([behavior_data])[0]

            # 텐서로 변환
            device = next(self.model.parameters()).device
            user_id = torch.tensor([user_idx]).to(device)
            product_id = torch.tensor([product_idx]).to(device)
            user_features = torch.tensor([gender_enc + age_enc + income_enc]).float().to(device)
            behavior_tensor = torch.tensor([behavior_data]).float().to(device)

            # 예측
            with torch.no_grad():
                prediction = self.model(
                    user_id,
                    product_id,
                    user_features,
                    behavior_tensor
                )
                
            return prediction.item()

        except Exception as e:
            print(f"Error in predict_user_interest: {str(e)}")
            return 0.0         
    

def save_model(model, user_to_idx, product_to_idx, scaler, path='model_weights'):
    try:
        # 모델 가중치 저장
        torch.save({
            'model_state_dict': model.state_dict(),
        }, f'{path}.pth')
        
        # 메타데이터와 scaler 상태 저장
        metadata = {
            'user_to_idx': user_to_idx,
            'product_to_idx': product_to_idx,
            'scaler_params': {
                'min_': scaler.min_,
                'scale_': scaler.scale_,
                'data_min_': scaler.data_min_,
                'data_max_': scaler.data_max_,
                'data_range_': scaler.data_range_,
                'feature_range': scaler.feature_range,
                'clip': scaler.clip
            }
        }
        torch.save(metadata, f'{path}_metadata.pth')
        return True
    except Exception as e:
        print(f"Error saving model: {e}")
        return False=== backend/products/models.py ===
# backend/products/models.py
from django.db import models
from django.contrib.auth.models import User
from imagekit.models import ImageSpecField
from imagekit.processors import ResizeToFit

class ProductCategory(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField(blank=True)
    
    def __str__(self):
        return self.name

class Product(models.Model):
    title = models.CharField(max_length=200)
    description = models.TextField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    image = models.ImageField(upload_to='products/')
    theme = models.CharField(max_length=100)
    category = models.ForeignKey(ProductCategory, on_delete=models.SET_NULL, null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    total_views = models.IntegerField(default=0)
    average_rating = models.FloatField(default=0.0)
    stock = models.IntegerField(default=0)
    
    # 썸네일 자동 생성 필드 추가
    thumbnail = ImageSpecField(
        source='image',
        processors=[ResizeToFit(width=600, height=600)],
        format='JPEG',
        options={'quality': 90}
    )
    list_thumbnail = ImageSpecField(
        source='image',
        processors=[ResizeToFit(width=300, height=300)],
        format='JPEG',
        options={'quality': 90}
    )

    def get_image_url(self):
        if self.image:
            return self.image.url
        return None
    
    class Meta:
        ordering = ['-created_at']
    
    def __str__(self):
        return self.title


class UserBehavior(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    view_duration = models.FloatField(default=0)
    click_count = models.IntegerField(default=0)
    cart_add_count = models.IntegerField(default=0)
    purchase_count = models.IntegerField(default=0)
    favorite_count = models.IntegerField(default=0)  # 추가
    review_score = models.FloatField(default=0)  # 추가
    last_viewed = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ['user', 'product']

class ProductView(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    view_duration = models.IntegerField()
    viewed_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        ordering = ['-viewed_at']

class UserProductRating(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    rating = models.IntegerField(choices=[(i, i) for i in range(1, 6)])
    content = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ['user', 'product']

class ProductFavorite(models.Model):
    """찜한 상품"""
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    created_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ['user', 'product']
        ordering = ['-created_at']
        
    def __str__(self):
        return f"{self.user.username}'s favorite: {self.product.title}"

class RecommendationLog(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    score = models.FloatField()
    recommended_at = models.DateTimeField(auto_now_add=True)
    clicked = models.BooleanField(default=False)
    purchased = models.BooleanField(default=False)
    
    class Meta:
        ordering = ['-recommended_at']
        
class ProductReview(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    rating = models.IntegerField(choices=[(i, i) for i in range(1, 6)])
    comment = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['-created_at']
        unique_together = ['user', 'product']
        
    def __str__(self):
        return f"{self.user.username}'s review on {self.product.title}"
    
class CartItem(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    product = models.ForeignKey(Product, on_delete=models.CASCADE)
    quantity = models.IntegerField(default=1)
    added_at = models.DateTimeField(auto_now_add=True)
    
    class Meta:
        unique_together = ['user', 'product']

    def __str__(self):
        return f"{self.user.username}'s cart - {self.product.title}"=== backend/products/serializers.py ===
# backend/products/serializers.py
from rest_framework import serializers
from .models import Product, UserProductRating, ProductReview, CartItem
from accounts.models import UserProfile  # UserProfile을 accounts에서 import

class ProductSerializer(serializers.ModelSerializer):
    image_url = serializers.SerializerMethodField()
    thumbnail_url = serializers.SerializerMethodField()
    list_thumbnail_url = serializers.SerializerMethodField()
    viewed_at = serializers.SerializerMethodField()

    class Meta:
        model = Product
        fields = [
            'id', 'title', 'description', 'price',
            'image_url', 'thumbnail_url', 'list_thumbnail_url',
            'theme', 'category', 'total_views', 
            'average_rating', 'stock', 'viewed_at'
        ]

    def get_viewed_at(self, obj):
        if not self.context.get('viewed_timestamps'):
            return None
        return self.context['viewed_timestamps'].get(obj.id)

    
    def get_image_url(self, obj):
        if obj.image:
            return obj.image.url
        return None

    def get_thumbnail_url(self, obj):
        if obj.image:  # 썸네일이 없을 경우 원본 이미지 반환
            try:
                return obj.thumbnail.url
            except:
                return obj.image.url
        return None

    def get_list_thumbnail_url(self, obj):
        if obj.image:  # 리스트 썸네일이 없을 경우 썸네일이나 원본 이미지 반환
            try:
                return obj.list_thumbnail.url
            except:
                try:
                    return obj.thumbnail.url
                except:
                    return obj.image.url
        return None

class UserProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserProfile
        fields = ['gender', 'age_group', 'income_level', 'preferred_categories']

class RatingSerializer(serializers.ModelSerializer):
    class Meta:
        model = UserProductRating
        fields = ['id', 'rating', 'created_at']

class ReviewSerializer(serializers.ModelSerializer):
    username = serializers.SerializerMethodField()
    
    class Meta:
        model = ProductReview
        fields = ['id', 'rating', 'comment', 'created_at', 'username']
        
    def get_username(self, obj):
        return obj.user.username
    
    
class CartItemSerializer(serializers.ModelSerializer):
    product = ProductSerializer()
    total_price = serializers.SerializerMethodField()

    class Meta:
        model = CartItem
        fields = ['id', 'product', 'quantity', 'total_price', 'added_at']

    def get_total_price(self, obj):
        return obj.quantity * obj.product.price=== backend/products/management/commands/generate_stereotype_data.py ===
# backend/products/management/commands/generate_stereotype_data.py

from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
from products.models import Product, ProductCategory, UserBehavior
from accounts.models import UserProfile  # UserProfile을 accounts에서 import
import random


class Command(BaseCommand):
    help = '사용자 그룹별 스테레오타입 데이터 생성'

    def handle(self, *args, **kwargs):
        # 카테고리 및 상품 정의
        categories_data = [
            {
                'name': '전자기기',
                'products': [
                    {'name': '기계식키보드', 'price': 158000, 'description': 'RGB 백라이트 탑재 게이밍 키보드'},
                    {'name': '게이밍마우스', 'price': 89000, 'description': '고성능 센서 탑재 게이밍 마우스'},
                    {'name': '노이즈캔슬링헤드폰', 'price': 290000, 'description': '프리미엄 무선 헤드폰'},
                    {'name': '게이밍노트북', 'price': 1890000, 'description': '고성능 게이밍 노트북'},
                    {'name': '태블릿PC', 'price': 890000, 'description': '대화면 태블릿'},
                    {'name': '스마트워치', 'price': 350000, 'description': '건강관리 스마트워치'}
                ]
            },
            {
                'name': '패션잡화',
                'products': [
                    {'name': '명품가방', 'price': 2890000, 'description': '프리미엄 브랜드 가방'},
                    {'name': '명품지갑', 'price': 890000, 'description': '프리미엄 브랜드 지갑'},
                    {'name': '명품벨트', 'price': 590000, 'description': '프리미엄 브랜드 벨트'},
                    {'name': '명품선글라스', 'price': 490000, 'description': '프리미엄 브랜드 선글라스'},
                    {'name': '캐주얼백팩', 'price': 89000, 'description': '실용적인 백팩'},
                    {'name': '크로스백', 'price': 159000, 'description': '데일리 크로스백'}
                ]
            },
            {
                'name': '화장품',
                'products': [
                    {'name': '고급스킨케어세트', 'price': 450000, 'description': '프리미엄 스킨케어 세트'},
                    {'name': '프리미엄립스틱', 'price': 68000, 'description': '고발색 럭셔리 립스틱'},
                    {'name': '명품향수', 'price': 250000, 'description': '고급 브랜드 향수'},
                    {'name': '프리미엄파운데이션', 'price': 89000, 'description': '완벽 커버 파운데이션'},
                    {'name': '기초화장품세트', 'price': 178000, 'description': '기초 스킨케어 세트'},
                    {'name': '메이크업팔레트', 'price': 98000, 'description': '올인원 메이크업 팔레트'}
                ]
            },
            {
                'name': '도서',
                'products': [
                    {'name': 'IT전문서적', 'price': 45000, 'description': '최신 IT 기술서'},
                    {'name': '자기계발서', 'price': 28000, 'description': '베스트셀러 자기계발서'},
                    {'name': '소설책', 'price': 25000, 'description': '인기 소설'},
                    {'name': '만화책', 'price': 15000, 'description': '인기 만화시리즈'},
                    {'name': '과학도서', 'price': 35000, 'description': '과학 교양서'},
                    {'name': '수험서', 'price': 38000, 'description': '자격증 수험서'}
                ]
            },
            {
                'name': '스포츠/레저',
                'products': [
                    {'name': '요가매트', 'price': 89000, 'description': '프리미엄 요가매트'},
                    {'name': '테니스라켓', 'price': 150000, 'description': '전문가용 테니스라켓'},
                    {'name': '골프클럽세트', 'price': 1290000, 'description': '프리미엄 골프클럽 세트'},
                    {'name': '러닝화', 'price': 159000, 'description': '고급 러닝화'},
                    {'name': '헬스용품세트', 'price': 250000, 'description': '홈트레이닝 세트'},
                    {'name': '등산용품', 'price': 280000, 'description': '등산 장비 세트'}
                ]
            },
            {
                'name': '문구/취미',
                'products': [
                    {'name': '프리미엄만년필', 'price': 280000, 'description': '고급 만년필'},
                    {'name': '미술용품세트', 'price': 150000, 'description': '전문가용 미술도구 세트'},
                    {'name': '다이어리', 'price': 35000, 'description': '프리미엄 다이어리'},
                    {'name': '필기구세트', 'price': 45000, 'description': '고급 필기구 세트'},
                    {'name': '스케치북', 'price': 25000, 'description': '전문가용 스케치북'},
                    {'name': '취미키트', 'price': 89000, 'description': 'DIY 취미 키트'}
                ]
            }
        ]

# 사용자 그룹별 선호도 정의
        user_preferences = {
            # 10대 그룹
            ('M', '10', 'L'): {  # 10대 남성 저소득
                '전자기기': 0.9,  # 게임, IT 기기에 매우 높은 관심
                '패션잡화': 0.3,
                '화장품': 0.1,
                '도서': 0.5,     # 만화, 게임 관련 서적
                '스포츠/레저': 0.4,
                '문구/취미': 0.6  # 학업 관련 문구
            },
            ('M', '10', 'M'): {  # 10대 남성 중소득
                '전자기기': 0.9,
                '패션잡화': 0.4,
                '화장품': 0.2,
                '도서': 0.6,
                '스포츠/레저': 0.5,
                '문구/취미': 0.6
            },
            ('M', '10', 'H'): {  # 10대 남성 고소득
                '전자기기': 1.0,
                '패션잡화': 0.5,
                '화장품': 0.2,
                '도서': 0.6,
                '스포츠/레저': 0.6,
                '문구/취미': 0.7
            },
            ('F', '10', 'L'): {  # 10대 여성 저소득
                '전자기기': 0.4,
                '패션잡화': 0.7,
                '화장품': 0.8,
                '도서': 0.6,
                '스포츠/레저': 0.3,
                '문구/취미': 0.8
            },
            ('F', '10', 'M'): {  # 10대 여성 중소득
                '전자기기': 0.5,
                '패션잡화': 0.8,
                '화장품': 0.9,
                '도서': 0.6,
                '스포츠/레저': 0.4,
                '문구/취미': 0.8
            },
            ('F', '10', 'H'): {  # 10대 여성 고소득
                '전자기기': 0.6,
                '패션잡화': 0.9,
                '화장품': 1.0,
                '도서': 0.6,
                '스포츠/레저': 0.5,
                '문구/취미': 0.9
            },

            # 20대 그룹
            ('M', '20', 'L'): {  # 20대 남성 저소득
                '전자기기': 0.8,
                '패션잡화': 0.4,
                '화장품': 0.2,
                '도서': 0.6,
                '스포츠/레저': 0.5,
                '문구/취미': 0.3
            },
            ('M', '20', 'M'): {
                '전자기기': 0.9,
                '패션잡화': 0.6,
                '화장품': 0.3,
                '도서': 0.6,
                '스포츠/레저': 0.6,
                '문구/취미': 0.4
            },
            ('M', '20', 'H'): {
                '전자기기': 1.0,
                '패션잡화': 0.8,
                '화장품': 0.4,
                '도서': 0.7,
                '스포츠/레저': 0.8,
                '문구/취미': 0.5
            },
            ('F', '20', 'L'): {
                '전자기기': 0.5,
                '패션잡화': 0.7,
                '화장품': 0.8,
                '도서': 0.6,
                '스포츠/레저': 0.4,
                '문구/취미': 0.5
            },
            ('F', '20', 'M'): {
                '전자기기': 0.6,
                '패션잡화': 0.8,
                '화장품': 0.9,
                '도서': 0.7,
                '스포츠/레저': 0.5,
                '문구/취미': 0.6
            },
            ('F', '20', 'H'): {
                '전자기기': 0.7,
                '패션잡화': 1.0,
                '화장품': 1.0,
                '도서': 0.7,
                '스포츠/레저': 0.6,
                '문구/취미': 0.7
            },

# 30대 그룹
            ('M', '30', 'L'): {
                '전자기기': 0.7,
                '패션잡화': 0.5,
                '화장품': 0.3,
                '도서': 0.6,
                '스포츠/레저': 0.6,
                '문구/취미': 0.3
            },
            ('M', '30', 'M'): {
                '전자기기': 0.8,
                '패션잡화': 0.7,
                '화장품': 0.4,
                '도서': 0.7,
                '스포츠/레저': 0.8,
                '문구/취미': 0.4
            },
            ('M', '30', 'H'): {
                '전자기기': 0.9,
                '패션잡화': 0.9,
                '화장품': 0.5,
                '도서': 0.8,
                '스포츠/레저': 0.9,
                '문구/취미': 0.5
            },
            ('F', '30', 'L'): {
                '전자기기': 0.4,
                '패션잡화': 0.7,
                '화장품': 0.8,
                '도서': 0.6,
                '스포츠/레저': 0.5,
                '문구/취미': 0.4
            },
            ('F', '30', 'M'): {
                '전자기기': 0.5,
                '패션잡화': 0.8,
                '화장품': 0.9,
                '도서': 0.7,
                '스포츠/레저': 0.7,
                '문구/취미': 0.5
            },
            ('F', '30', 'H'): {
                '전자기기': 0.6,
                '패션잡화': 1.0,
                '화장품': 1.0,
                '도서': 0.8,
                '스포츠/레저': 0.8,
                '문구/취미': 0.6
            },

            # 40대 그룹
            ('M', '40', 'L'): {
                '전자기기': 0.5,
                '패션잡화': 0.4,
                '화장품': 0.2,
                '도서': 0.6,
                '스포츠/레저': 0.7,
                '문구/취미': 0.3
            },
            ('M', '40', 'M'): {
                '전자기기': 0.6,
                '패션잡화': 0.6,
                '화장품': 0.3,
                '도서': 0.7,
                '스포츠/레저': 0.9,
                '문구/취미': 0.4
            },
            ('M', '40', 'H'): {
                '전자기기': 0.7,
                '패션잡화': 0.8,
                '화장품': 0.4,
                '도서': 0.8,
                '스포츠/레저': 1.0,
                '문구/취미': 0.5
            },
            ('F', '40', 'L'): {
                '전자기기': 0.3,
                '패션잡화': 0.6,
                '화장품': 0.7,
                '도서': 0.6,
                '스포츠/레저': 0.6,
                '문구/취미': 0.4
            },
            ('F', '40', 'M'): {
                '전자기기': 0.4,
                '패션잡화': 0.8,
                '화장품': 0.8,
                '도서': 0.7,
                '스포츠/레저': 0.8,
                '문구/취미': 0.5
            },
            ('F', '40', 'H'): {
                '전자기기': 0.5,
                '패션잡화': 0.9,
                '화장품': 0.9,
                '도서': 0.8,
                '스포츠/레저': 0.9,
                '문구/취미': 0.6
            },

            # 50대 이상 그룹
            ('M', '50', 'L'): {
                '전자기기': 0.3,
                '패션잡화': 0.3,
                '화장품': 0.1,
                '도서': 0.7,
                '스포츠/레저': 0.8,
                '문구/취미': 0.4
            },
            ('M', '50', 'M'): {
                '전자기기': 0.4,
                '패션잡화': 0.5,
                '화장품': 0.2,
                '도서': 0.8,
                '스포츠/레저': 0.9,
                '문구/취미': 0.5
            },
            ('M', '50', 'H'): {
                '전자기기': 0.5,
                '패션잡화': 0.7,
                '화장품': 0.3,
                '도서': 0.9,
                '스포츠/레저': 1.0,
                '문구/취미': 0.6
            },
            ('F', '50', 'L'): {
                '전자기기': 0.2,
                '패션잡화': 0.5,
                '화장품': 0.6,
                '도서': 0.7,
                '스포츠/레저': 0.7,
                '문구/취미': 0.5
            },
            ('F', '50', 'M'): {
                '전자기기': 0.3,
                '패션잡화': 0.7,
                '화장품': 0.7,
                '도서': 0.8,
                '스포츠/레저': 0.8,
                '문구/취미': 0.6
            },
            ('F', '50', 'H'): {
                '전자기기': 0.4,
                '패션잡화': 0.8,
                '화장품': 0.8,
                '도서': 0.9,
                '스포츠/레저': 0.9,
                '문구/취미': 0.7
            },
        }

# 테스트 사용자 생성
        test_users = [
            # 10대 테스트 사용자
            {'username': 'male_10_low', 'gender': 'M', 'age': '10', 'income': 'L'},
            {'username': 'male_10_mid', 'gender': 'M', 'age': '10', 'income': 'M'},
            {'username': 'male_10_high', 'gender': 'M', 'age': '10', 'income': 'H'},
            {'username': 'female_10_low', 'gender': 'F', 'age': '10', 'income': 'L'},
            {'username': 'female_10_mid', 'gender': 'F', 'age': '10', 'income': 'M'},
            {'username': 'female_10_high', 'gender': 'F', 'age': '10', 'income': 'H'},

            # 20대 테스트 사용자
            {'username': 'male_20_low', 'gender': 'M', 'age': '20', 'income': 'L'},
            {'username': 'male_20_mid', 'gender': 'M', 'age': '20', 'income': 'M'},
            {'username': 'male_20_high', 'gender': 'M', 'age': '20', 'income': 'H'},
            {'username': 'female_20_low', 'gender': 'F', 'age': '20', 'income': 'L'},
            {'username': 'female_20_mid', 'gender': 'F', 'age': '20', 'income': 'M'},
            {'username': 'female_20_high', 'gender': 'F', 'age': '20', 'income': 'H'},

            # 30대 테스트 사용자
            {'username': 'male_30_low', 'gender': 'M', 'age': '30', 'income': 'L'},
            {'username': 'male_30_mid', 'gender': 'M', 'age': '30', 'income': 'M'},
            {'username': 'male_30_high', 'gender': 'M', 'age': '30', 'income': 'H'},
            {'username': 'female_30_low', 'gender': 'F', 'age': '30', 'income': 'L'},
            {'username': 'female_30_mid', 'gender': 'F', 'age': '30', 'income': 'M'},
            {'username': 'female_30_high', 'gender': 'F', 'age': '30', 'income': 'H'},

            # 40대 테스트 사용자
            {'username': 'male_40_low', 'gender': 'M', 'age': '40', 'income': 'L'},
            {'username': 'male_40_mid', 'gender': 'M', 'age': '40', 'income': 'M'},
            {'username': 'male_40_high', 'gender': 'M', 'age': '40', 'income': 'H'},
            {'username': 'female_40_low', 'gender': 'F', 'age': '40', 'income': 'L'},
            {'username': 'female_40_mid', 'gender': 'F', 'age': '40', 'income': 'M'},
            {'username': 'female_40_high', 'gender': 'F', 'age': '40', 'income': 'H'},

            # 50대 테스트 사용자
            {'username': 'male_50_low', 'gender': 'M', 'age': '50', 'income': 'L'},
            {'username': 'male_50_mid', 'gender': 'M', 'age': '50', 'income': 'M'},
            {'username': 'male_50_high', 'gender': 'M', 'age': '50', 'income': 'H'},
            {'username': 'female_50_low', 'gender': 'F', 'age': '50', 'income': 'L'},
            {'username': 'female_50_mid', 'gender': 'F', 'age': '50', 'income': 'M'},
            {'username': 'female_50_high', 'gender': 'F', 'age': '50', 'income': 'H'},
        ]

        # 카테고리와 상품 생성
        self.stdout.write('카테고리와 상품 생성 중...')
        for category_data in categories_data:
            category, _ = ProductCategory.objects.get_or_create(
                name=category_data['name'],
                defaults={'description': f'{category_data["name"]} 카테고리입니다.'}
            )
            
            for product_data in category_data['products']:
                Product.objects.get_or_create(
                    title=product_data['name'],
                    defaults={
                        'description': product_data.get('description', f'{product_data["name"]} 상품입니다.'),
                        'price': product_data['price'],
                        'theme': category.name,
                        'category': category,
                        'stock': random.randint(10, 100)
                    }
                )

        # 테스트 사용자 생성
        self.stdout.write('테스트 사용자 생성 중...')
        for user_data in test_users:
            user, created = User.objects.get_or_create(
                username=user_data['username'],
                defaults={
                    'email': f"{user_data['username']}@example.com",
                }
            )
            
            if created:
                user.set_password('testpass123')
                user.save()
                
                # 사용자 프로필 생성
                profile = UserProfile.objects.create(
                    user=user,
                    gender=user_data['gender'],
                    age_group=user_data['age'],
                    income_level=user_data['income']
                )

                # 초기 행동 데이터 생성
                preferences = user_preferences[(user_data['gender'], user_data['age'], user_data['income'])]
                
                for category_name, preference_score in preferences.items():
                    category_products = Product.objects.filter(category__name=category_name)
                    
                    for product in category_products:
                        # 선호도에 따라 클릭 수와 체류 시간 설정
                        if random.random() < preference_score:
                            UserBehavior.objects.create(
                                user=user,
                                product=product,
                                view_duration=random.randint(30, 300),
                                click_count=random.randint(1, 5) if random.random() < preference_score else 0,
                                cart_add_count=1 if random.random() < preference_score * 0.5 else 0,
                                purchase_count=1 if random.random() < preference_score * 0.3 else 0
                            )

        self.stdout.write(self.style.SUCCESS('스테레오타입 데이터 생성 완료!'))=== backend/products/management/commands/update_product_images.py ===
from django.core.management.base import BaseCommand
from django.core.files import File
from products.models import Product
import os

class Command(BaseCommand):
    help = '상품 이미지 업데이트'

    def handle(self, *args, **kwargs):
        # 이미지 파일 매핑
        image_mapping = {
            'IT전문서적': 'IT전문서적.jpeg',
            '고급스킨케어세트': '고급스킨케어세트.jpeg',
            '과학도서': '과학도서.jpeg',
            '게이밍노트북': '게이밍노트북.png',
            '게이밍마우스': '게이밍마우스.jpeg',
            '골프클럽세트': '골프클럽세트.jpeg',
            '기계식키보드': '기계식키보드.png',
            '기초화장품세트': '기초화장품세트.png',
            '노이즈캔슬링헤드폰': '노이즈캔슬링헤드폰.jpeg',
            '다이어리': '다이어리.jpeg',
            '러닝화': '러닝화.png',
            '만화책': '만화책.jpeg',
            '메이크업팔레트': '메이크업팔레트.png',
            '명품가방': '명품가방.jpeg',
            '명품벨트': '명품벨트.png',
            '명품선글라스': '명품선글라스.png',
            '명품지갑': '명품지갑.png',
            '명품향수': '명품향수.png',
            '미술용품세트': '미술용품세트.jpeg',
            '소설책': '소설책.png',
            '수험서': '수험서.jpeg',
            '스케치북': '스케치북.jpeg',
            '스마트워치': '스마트워치.png',
            '요가매트': '요가매트.png',
            '자기계발서': '자기계발서.jpeg',
            '테니스라켓': '테니스라켓.png',
            '태블릿PC': '태블릿PC.png',
            '프리미엄립스틱': '프리미엄립스틱.jpeg',
            '프리미엄만년필': '프리미엄만년필.jpeg',
            '프리미엄파운데이션': '프리미엄파운데이션.png',
            '필기구세트': '필기구세트.jpeg',
            '헬스용품세트': '헬스용품세트.png',
            '크로스백': '크로스백.jpeg',
            '캐주얼백팩': '캐주얼백팩.jpeg',
            '취미키트': '취미키트.jpeg',
            '등산용품': '등산용품.jpeg'
        }

        # 이미지 디렉토리 경로
        media_root = 'media'
        products_dir = os.path.join(media_root, 'products')
        
        # 디렉토리 존재 확인
        if not os.path.exists(products_dir):
            self.stdout.write(self.style.WARNING(f'Creating directory: {products_dir}'))
            os.makedirs(products_dir)
        
        success_count = 0
        error_count = 0
        skipped_count = 0
        
        self.stdout.write(self.style.NOTICE('Starting image update process...'))

        # 각 상품의 이미지 업데이트
        for product in Product.objects.all():
            try:
                if product.title in image_mapping:
                    image_name = image_mapping[product.title]
                    image_path = os.path.join('products', image_name)
                    full_path = os.path.join(media_root, 'products', image_name)
                    
                    if os.path.exists(full_path):
                        # 기존 이미지가 있다면 삭제
                        if product.image:
                            product.image.delete(save=False)
                        
                        # 새 이미지 설정
                        with open(full_path, 'rb') as img_file:
                            product.image.save(image_name, File(img_file), save=True)
                        success_count += 1
                        self.stdout.write(
                            self.style.SUCCESS(f'✓ Updated image for {product.title}')
                        )
                    else:
                        error_count += 1
                        self.stdout.write(
                            self.style.ERROR(f'✗ Image file not found: {full_path}')
                        )
                else:
                    skipped_count += 1
                    self.stdout.write(
                        self.style.WARNING(f'⚠ No image mapping for: {product.title}')
                    )
                    
            except Exception as e:
                error_count += 1
                self.stdout.write(
                    self.style.ERROR(f'✗ Error processing {product.title}: {str(e)}')
                )

        # 최종 결과 출력
        self.stdout.write('\nUpdate process completed:')
        self.stdout.write(self.style.SUCCESS(f'Successfully updated: {success_count}'))
        self.stdout.write(self.style.ERROR(f'Errors: {error_count}'))
        self.stdout.write(self.style.WARNING(f'Skipped: {skipped_count}'))=== backend/products/management/commands/train_recommender.py ===
# backend/products/management/commands/train_recommender.py
from django.core.management.base import BaseCommand
from products.training import train_model
from django.contrib.auth.models import User
from accounts.models import UserProfile  # UserProfile을 accounts에서 import


class Command(BaseCommand):
    help = '추천 시스템 모델 재훈련'

    def add_arguments(self, parser):
        parser.add_argument(
            '--epochs',
            type=int,
            default=10,
            help='훈련 에포크 수'
        )

    def handle(self, *args, **kwargs):
        epochs = kwargs['epochs']
        self.stdout.write('추천 시스템 모델 훈련 시작...')
        
        try:
            train_model(epochs=epochs)
            self.stdout.write(self.style.SUCCESS('모델 훈련 완료!'))
        except Exception as e:
            self.stdout.write(self.style.ERROR(f'훈련 중 에러 발생: {str(e)}'))=== backend/products/__init__.py ===
=== backend/products/apps.py ===
# backend/products/apps.py
from django.apps import AppConfig

class ProductsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'products'
=== backend/products/admin.py ===
# backend/products/admin.py
from django.contrib import admin
from .models import Product

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ['title', 'price', 'theme', 'created_at']
    list_filter = ['theme']
    search_fields = ['title', 'description']
=== backend/products/tests.py ===
# backend/products/tests.py
from django.test import TestCase

# Create your tests here.
=== backend/products/urls.py ===
# products/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from . import views
# products/urls.py
router = DefaultRouter()
router.register(r'products', views.ProductViewSet)
router.register(r'cart', views.CartViewSet, basename='cart')

urlpatterns = [
    path('', include(router.urls)),
    path('user-activity/', include([
        path('viewed/', views.ViewedProductsView.as_view(), name='viewed-products'),
        path('favorites/', views.FavoriteProductsView.as_view(), name='favorite-products'),
        path('reviews/', views.UserReviewsView.as_view(), name='user-reviews'),
        path('viewed/<int:pk>/', views.ViewedProductsView.as_view(), name='delete-viewed'),
        path('reviews/<int:pk>/', views.UserReviewsView.as_view(), name='delete-review'),
    ])),
]=== backend/products/training.py ===
import torch
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset
from datetime import datetime, timedelta
from .models import *
from .ml_models import ProductRecommender
import numpy as np
from sklearn.preprocessing import MinMaxScaler
import pickle
from torch.serialization import add_safe_globals

# 필요한 모든 타입을 안전한 글로벌로 등록
add_safe_globals([
    MinMaxScaler,
    dict,
    np.ndarray,
    torch.nn.Parameter,
    torch._utils._rebuild_tensor_v2
])

class RecommendationDataset(Dataset):
    def __init__(self):
        self.users = list(User.objects.all())
        self.products = list(Product.objects.all())
        self.user_to_idx = {user.id: idx for idx, user in enumerate(self.users)}
        self.product_to_idx = {product.id: idx for idx, product in enumerate(self.products)}
        self.interactions = UserBehavior.objects.all()
        self.scaler = MinMaxScaler()
        self.prepare_data()
            
    def prepare_data(self):
        self.training_data = []
        all_behavior_data = []

        # 첫 번째 패스: 행동 데이터 수집 및 스케일러 피팅
        print("행동 데이터 수집 중...")
        for interaction in self.interactions:
            try:
                behavior_data = [
                    interaction.click_count,
                    interaction.view_duration,
                    interaction.cart_add_count
                ]
                all_behavior_data.append(behavior_data)
            except Exception as e:
                print(f"행동 데이터 수집 중 오류 발생: {e}")
                continue

        # 스케일러 피팅
        if all_behavior_data:
            print(f"총 {len(all_behavior_data)}개의 행동 데이터로 스케일러 피팅")
            self.scaler.fit(all_behavior_data)
        else:
            print("행동 데이터가 없습니다.")
            return

        # 두 번째 패스: 훈련 데이터 생성
        print("훈련 데이터 생성 중...")
        for interaction in self.interactions:
            try:
                user_profile = interaction.user.userprofile

                # 사용자 특성 원-핫 인코딩
                gender_enc = [0, 0, 0]
                gender_enc[['M', 'F', 'O'].index(user_profile.gender)] = 1

                age_enc = [0, 0, 0, 0, 0]
                age_enc[['10', '20', '30', '40', '50'].index(user_profile.age_group)] = 1

                income_enc = [0, 0, 0]
                income_enc[['L', 'M', 'H'].index(user_profile.income_level)] = 1

                # 행동 데이터 정규화
                behavior_data = np.array([
                    interaction.click_count,
                    interaction.view_duration,
                    interaction.cart_add_count
                ]).reshape(1, -1)
                behavior_data = self.scaler.transform(behavior_data)[0]

                # 목표값 (구매 여부)
                target = 1.0 if interaction.purchase_count > 0 else 0.0

                user_idx = self.user_to_idx[interaction.user.id]
                product_idx = self.product_to_idx[interaction.product.id]

                self.training_data.append({
                    'user_id': user_idx,
                    'product_id': product_idx,
                    'user_features': gender_enc + age_enc + income_enc,
                    'behavior_data': behavior_data.tolist(),
                    'target': target
                })
            except Exception as e:
                print(f"훈련 데이터 생성 중 오류 발생: {e}")
                continue

        print(f"총 {len(self.training_data)}개의 훈련 데이터 생성 완료")

    def __len__(self):
        return len(self.training_data)
    
    def __getitem__(self, idx):
        item = self.training_data[idx]
        return (
            torch.tensor(item['user_id']),
            torch.tensor(item['product_id']),
            torch.tensor(item['user_features'], dtype=torch.float),
            torch.tensor(item['behavior_data'], dtype=torch.float),
            torch.tensor(item['target'], dtype=torch.float)
        )
        
def save_model(model, user_to_idx, product_to_idx, scaler, path='model_weights'):
    """모델과 메타데이터를 안전하게 저장"""
    try:
        # weights_only 파라미터 제거
        torch.save({
            'model_state_dict': model.state_dict(),
        }, f'{path}.pth')
        
        # 메타데이터 별도 저장
        metadata = {
            'user_to_idx': user_to_idx,
            'product_to_idx': product_to_idx,
            'scaler_params': {
                'min_': scaler.min_,
                'scale_': scaler.scale_,
                'data_min_': getattr(scaler, 'data_min_', None),
                'data_max_': getattr(scaler, 'data_max_', None),
                'data_range_': getattr(scaler, 'data_range_', None)
            }
        }
        torch.save(metadata, f'{path}_metadata.pth')
        print("모델이 안전하게 저장되었습니다.")
        return True
    except Exception as e:
        print(f"모델 저장 중 오류 발생: {e}")
        return False   

def train_model(epochs=10, batch_size=32, learning_rate=0.001):
    try:
        print("데이터셋 초기화 중...")
        dataset = RecommendationDataset()
        
        if len(dataset) == 0:
            raise ValueError("훈련 데이터가 없습니다!")
        
        print(f"총 {len(dataset)}개의 훈련 데이터로 학습을 시작합니다.")
        
        # 데이터로더 설정
        dataloader = DataLoader(
            dataset, 
            batch_size=min(batch_size, len(dataset)), 
            shuffle=True
        )
        
        # 모델 초기화
        device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')
        print(f"디바이스: {device}")
        
        model = ProductRecommender(
            n_users=len(dataset.users),
            n_products=len(dataset.products)
        )
        model.to(device)
        
        optimizer = optim.Adam(model.parameters(), lr=learning_rate)
        criterion = torch.nn.BCELoss()
        
        # 훈련 루프
        print("모델 훈련 시작...")
        best_loss = float('inf')
        for epoch in range(epochs):
            model.train()
            total_loss = 0
            for batch in dataloader:
                # 배치 데이터를 GPU로 이동
                user_ids, product_ids, user_features, behavior_data, targets = [
                    x.to(device) for x in batch
                ]
                
                optimizer.zero_grad()
                predictions = model(user_ids, product_ids, user_features, behavior_data)
                loss = criterion(predictions.squeeze(), targets)
                
                loss.backward()
                optimizer.step()
                
                total_loss += loss.item()
            
            avg_loss = total_loss / len(dataloader)
            print(f'Epoch {epoch+1}/{epochs}, Loss: {avg_loss:.4f}')

            # 베스트 모델 저장
            if avg_loss < best_loss:
                best_loss = avg_loss
                print(f"새로운 best loss ({best_loss:.4f}) 달성, 모델 저장 중...")
                
                # 안전한 방식으로 모델 저장
                save_success = save_model(
                    model=model,
                    user_to_idx=dataset.user_to_idx,
                    product_to_idx=dataset.product_to_idx,
                    scaler=dataset.scaler,
                    path='model_weights'
                )
                
                if save_success:
                    print("모델이 안전하게 저장되었습니다.")
                else:
                    print("모델 저장 중 오류가 발생했습니다.")

        
        print(f"훈련 완료! 최종 Loss: {best_loss:.4f}")
        return True

    except Exception as e:
        print(f"모델 훈련 중 에러 발생: {str(e)}")
        return False=== backend/products/views.py ===
# products/views.py
from .models import Product, ProductView, UserBehavior, UserProductRating, ProductFavorite, RecommendationLog, CartItem
from .serializers import ProductSerializer
from .serializers import CartItemSerializer
from rest_framework import viewsets, status
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated
from django.db.models import Avg, F, Q, Max, Case, When, Value, DateTimeField, Subquery, OuterRef
from django.db.models.functions import Greatest, Coalesce
from django.db import transaction
from django.utils import timezone
from datetime import datetime
from .services import RecommendationService 
from django.contrib.auth.models import User
from django.shortcuts import get_object_or_404
from django.http import JsonResponse
from rest_framework.pagination import PageNumberPagination
from rest_framework.views import APIView
import pytz
import logging
from decimal import Decimal  # 상단에 추가

logger = logging.getLogger(__name__)


class ProductViewSet(viewsets.ModelViewSet):
    """
    상품 관련 ViewSet
    """
    queryset = Product.objects.all()
    serializer_class = ProductSerializer

    @action(detail=True, methods=['DELETE'])
    def viewed(self, request, pk=None):
        """최근 본 상품 삭제"""
        try:
            ProductView.objects.filter(
                user=request.user,
                product_id=pk
            ).delete()
            return Response({'status': 'success'})
        except Exception as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=True, methods=['DELETE'])
    def reviews(self, request, pk=None):
        """리뷰 삭제"""
        try:
            UserProductRating.objects.filter(
                user=request.user,
                id=pk
            ).delete()
            return Response({'status': 'success'})
        except Exception as e:
            return Response(
                {'error': str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


    def get_permissions(self):
        if self.action in ['add_to_cart', 'check_cart']:
            return [IsAuthenticated()]
        return super().get_permissions()


    @action(detail=True, methods=['POST'])
    def log_interaction(self, request, pk=None):
        """사용자 상품 상호작용 로깅"""
        try:
            product = self.get_object()
            interaction_type = request.data.get('type', '')
            duration = request.data.get('duration', 0)
            
            try:
                duration = float(duration)
            except (TypeError, ValueError):
                duration = 0.0

            with transaction.atomic():
                # **추가: 디버깅 로그로 데이터 확인**
                print(f"[DEBUG] Logging interaction for user {request.user}, product {product}, duration {duration}")
                
                # 조회수 증가
                Product.objects.filter(id=product.id).update(total_views=F('total_views') + 1)
                
                if request.user.is_authenticated:
                    # 조회 기록 생성
                    ProductView.objects.create(
                        user=request.user,
                        product=product,
                        view_duration=int(duration)
                    )

                    # 행동 데이터 업데이트
                    behavior, created = UserBehavior.objects.get_or_create(
                        user=request.user,
                        product=product,
                        defaults={
                            'view_duration': duration,
                            'click_count': 1,
                            'cart_add_count': 0,
                            'purchase_count': 0,
                            'last_viewed': timezone.now()
                        }
                    )
                    if not created:
                        behavior.view_duration += duration
                        behavior.click_count += 1
                        behavior.last_viewed = timezone.now()
                        behavior.save()
                        
            return Response({'status': 'success'})
            
        except Exception as e:
            print(f"[ERROR] Failed to log interaction: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)


    @action(detail=True, methods=['POST'])
    def toggle_favorite(self, request, pk=None):
        """상품 찜 상태 토글"""
        try:
            if not request.user.is_authenticated:
                return Response({'error': '로그인이 필요한 서비스입니다.'}, status=status.HTTP_401_UNAUTHORIZED)

            product = self.get_object()
            favorite = ProductFavorite.objects.filter(user=request.user, product=product).first()

            if favorite:
                favorite.delete()
                message = '찜하기가 취소되었습니다.'
                is_favorited = False
            else:
                ProductFavorite.objects.create(user=request.user, product=product)
                message = '상품을 찜했습니다.'
                is_favorited = True

            # **추가: 상태 확인 디버깅 로그**
            print(f"[DEBUG] Favorite toggled for user {request.user}, product {product}, is_favorited: {is_favorited}")
            
            return Response({
                'status': 'favorited' if is_favorited else 'unfavorited',
                'message': message,
                'is_favorited': is_favorited
            })

        except Exception as e:
            print(f"[ERROR] Toggle favorite error: {str(e)}")
            return Response({'error': str(e)}, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['POST'])
    def add_review(self, request, pk=None):
        """리뷰 추가"""
        try:
            if not request.user.is_authenticated:
                return Response({'error': '로그인이 필요한 서비스입니다.'}, status=status.HTTP_401_UNAUTHORIZED)

            product = self.get_object()
            rating = request.data.get('rating')
            content = request.data.get('content', '')

            # **추가: 유효성 검사 디버깅 로그**
            print(f"[DEBUG] Add review for user {request.user}, product {product}, rating {rating}, content: {content}")

            try:
                rating = int(rating)
            except (TypeError, ValueError):
                return Response({'error': '평점은 1-5 사이의 정수여야 합니다.'}, status=status.HTTP_400_BAD_REQUEST)

            if not (1 <= rating <= 5):
                return Response({'error': '평점은 1-5 사이의 정수여야 합니다.'}, status=status.HTTP_400_BAD_REQUEST)

            # 리뷰 생성 또는 업데이트
            rating_obj, created = UserProductRating.objects.update_or_create(
                user=request.user,
                product=product,
                defaults={
                    'rating': rating,
                    'content': content
                }
            )

            # 평균 평점 업데이트
            avg_rating = UserProductRating.objects.filter(product=product).aggregate(Avg('rating'))['rating__avg']
            product.average_rating = avg_rating or 0
            product.save()

            return Response({
                'status': 'success',
                'average_rating': product.average_rating,
                'message': '리뷰가 등록되었습니다.'
            })

        except Exception as e:
            print(f"[ERROR] Add review error: {str(e)}")
            return Response({'error': '리뷰 등록 중 오류가 발생했습니다.'}, status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['GET'])
    def reviews(self, request, pk=None):
        """상품 리뷰 목록 조회"""
        try:
            product = self.get_object()
            reviews = UserProductRating.objects.filter(product=product)\
                .select_related('user')\
                .order_by('-created_at')  # 최신순 정렬
            
            review_data = []
            for review in reviews:
                review_data.append({
                    'id': review.id,
                    'user': review.user.username,
                    'rating': review.rating,
                    'content': review.content,  # 리뷰 내용 포함
                    'created_at': review.created_at.strftime('%Y-%m-%d %H:%M')
                })
                
            return Response(review_data)
            
        except Exception as e:
            print(f"Error fetching reviews: {str(e)}")
            return Response(
                {'error': '리뷰를 불러오는 중 오류가 발생했습니다.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            ) 
                    
    @action(detail=True, methods=['GET'])
    def check_cart(self, request, pk=None):
        """장바구니 상태 확인"""
        try:
            product = self.get_object()
            if not request.user.is_authenticated:
                return Response({
                    'in_cart': False
                })
                
            # CartItem 테이블에서 확인
            in_cart = CartItem.objects.filter(
                user=request.user,
                product=product
            ).exists()
            
            return Response({
                'in_cart': in_cart
            })
        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_400_BAD_REQUEST
            )

    @action(detail=True, methods=['POST'])
    def update_cart_quantity(self, request, pk=None):
        try:
            quantity = int(request.data.get('quantity', 1))
            if quantity < 1:
                return Response(
                    {'error': '수량은 1 이상이어야 합니다.'}, 
                    status=status.HTTP_400_BAD_REQUEST
                )

            behavior, created = UserBehavior.objects.get_or_create(
                user=request.user,
                product_id=pk,
                defaults={'cart_add_count': quantity}
            )
            
            if not created:
                behavior.cart_add_count = quantity
                behavior.save()

            return Response({
                'status': 'success',
                'quantity': quantity,
                'total_price': float(behavior.product.price * quantity)
            })

        except Product.DoesNotExist:
            return Response(
                {'error': '상품을 찾을 수 없습니다.'}, 
                status=status.HTTP_404_NOT_FOUND
            )
        except Exception as e:
            print(f"Error updating cart quantity: {str(e)}")
            return Response(
                {'error': '수량 변경에 실패했습니다.'}, 
                status=status.HTTP_400_BAD_REQUEST
            )

            
    @action(detail=True, methods=['POST', 'DELETE'])  # DELETE 메서드 추가
    def remove_from_cart(self, request, pk=None):
        """장바구니에서 제거"""
        try:
            if not request.user.is_authenticated:
                return Response(
                    {'error': '로그인이 필요한 서비스입니다.'}, 
                    status=status.HTTP_401_UNAUTHORIZED
                )

            product = self.get_object()
            
            # CartItem에서 제거
            CartItem.objects.filter(
                user=request.user,
                product=product
            ).delete()

            return Response({
                'status': 'success',
                'message': '장바구니에서 제거되었습니다.'
            })

        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_400_BAD_REQUEST
            )

                
    @action(detail=False, methods=['GET'])
    def themes(self, request):
        """테마별 상품 목록 제공"""
        try:
            themes = {
                '전자기기': Product.objects.filter(theme='전자기기'),
                '패션잡화': Product.objects.filter(theme='패션잡화'),
                '화장품': Product.objects.filter(theme='화장품'),
                '도서': Product.objects.filter(theme='도서'),
                '스포츠/레저': Product.objects.filter(theme='스포츠/레저'),
                '문구/취미': Product.objects.filter(theme='문구/취미')
            }
            
            response_data = []
            for theme_name, products in themes.items():
                if products.exists():
                    serializer = ProductSerializer(products, many=True)
                    response_data.append({
                        'title': theme_name,
                        'products': serializer.data
                    })
            
            return Response(response_data)
                
        except Exception as e:
            print(f"Themes endpoint error: {str(e)}")
            return Response(
                {'error': '테마 데이터를 불러오는데 실패했습니다.'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

    @action(detail=False, methods=['GET'])
    def recommendations(self, request):
        try:
            limit = int(request.query_params.get('limit', 8))
            current_id = request.query_params.get('current_id')
            
            if current_id:
                try:
                    current_product = Product.objects.get(id=current_id)
                    
                    # 로그인한 사용자의 경우 선호도 기반 추천
                    if request.user.is_authenticated:
                        recommendation_service = RecommendationService(request.user)
                        
                        # 현재 상품을 제외한 모든 상품에 대해 예측 점수 계산
                        all_products = Product.objects.exclude(id=current_id)
                        predictions = []
                        
                        for product in all_products:
                            try:
                                score = recommendation_service.predict_user_interest(product.id)
                                # 같은 카테고리 상품에 약간의 가중치 부여
                                if product.category == current_product.category:
                                    score *= 1.2
                                predictions.append((product, score))
                            except Exception as e:
                                print(f"Error predicting for product {product.id}: {str(e)}")
                                continue
                        
                        # 예측 점수로 정렬하고 랜덤성 추가
                        predictions.sort(key=lambda x: (x[1] + random.random() * 0.2), reverse=True)
                        recommended_products = [pred[0] for pred in predictions[:limit]]
                        
                    else:
                        # 비로그인 사용자를 위한 랜덤 추천
                        # 현재 카테고리에서 60%, 다른 카테고리에서 40%
                        same_category_limit = int(limit * 0.6)
                        other_category_limit = limit - same_category_limit
                        
                        # 같은 카테고리에서 랜덤 선택
                        same_category_products = list(
                            Product.objects.filter(category=current_product.category)
                            .exclude(id=current_id)
                            .order_by('?')[:same_category_limit]
                        )
                        
                        # 다른 카테고리에서 랜덤 선택
                        other_products = list(
                            Product.objects.exclude(category=current_product.category)
                            .exclude(id=current_id)
                            .order_by('?')[:other_category_limit]
                        )
                        
                        recommended_products = same_category_products + other_products
                        random.shuffle(recommended_products)  # 최종 결과 섞기
                    
                    serializer = self.get_serializer(recommended_products, many=True)
                    return Response(serializer.data)
                    
                except Product.DoesNotExist:
                    return Response({"error": "Current product not found"}, status=404)
                    
            else:
                # 일반 추천 로직 (기존과 동일)
                if not request.user.is_authenticated:
                    products = Product.objects.all().order_by('?')[:limit]
                    serializer = self.get_serializer(products, many=True)
                    return Response(serializer.data)

                recommendation_service = RecommendationService(request.user)
                recommended_products = recommendation_service.get_recommendations(limit=limit)
                serializer = self.get_serializer(recommended_products, many=True)
                return Response(serializer.data)
                        
        except Exception as e:
            print(f"Recommendation error: {str(e)}")
            products = Product.objects.all().order_by('?')[:limit]
            serializer = self.get_serializer(products, many=True)
            return Response(serializer.data)
            
    @action(detail=True, methods=['GET'])
    def check_review(self, request, pk=None):
        """현재 사용자의 해당 상품 리뷰 존재 여부 확인"""
        try:
            if not request.user.is_authenticated:
                return Response(
                    {'error': '로그인이 필요한 서비스입니다.'}, 
                    status=status.HTTP_401_UNAUTHORIZED
                )

            product = self.get_object()
            review = UserProductRating.objects.filter(
                user=request.user,
                product=product
            ).first()

            if review:
                return Response({
                    'hasReview': True,
                    'review': {
                        'rating': review.rating,
                        'content': review.content,
                        'created_at': review.created_at
                    }
                })
            return Response({'hasReview': False})

        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
            
class CartViewSet(viewsets.ModelViewSet):
    permission_classes = [IsAuthenticated]  # 로그인한 사용자만 접근 가능
    
    def get_queryset(self):
        # 현재 로그인한 사용자의 장바구니 아이템만 반환
        return CartItem.objects.filter(user=self.request.user)
        
    def get_serializer_class(self):
        return CartItemSerializer
    
    @action(detail=False, methods=['POST'], permission_classes=[IsAuthenticated])
    def add_multiple(self, request):
        """여러 상품을 장바구니에 한 번에 추가"""
        try:
            product_ids = request.data.get('productIds', [])
            
            if not isinstance(product_ids, list):
                return Response(
                    {"error": "올바르지 않은 상품 목록입니다"}, 
                    status=status.HTTP_400_BAD_REQUEST
                )
                
            added_products = []
            failed_products = []
            
            with transaction.atomic():
                for product_id in product_ids:
                    try:
                        # 상품 존재 확인
                        product = Product.objects.get(id=product_id)
                        
                        # 재고 확인
                        if product.stock <= 0:
                            failed_products.append({
                                "product_id": product_id,
                                "error": "재고가 부족합니다"
                            })
                            continue
                        
                        # 장바구니에 이미 있는지 확인 후 추가 또는 업데이트
                        cart_item, created = CartItem.objects.get_or_create(
                            user=request.user,
                            product=product,
                            defaults={'quantity': 1}
                        )
                        
                        if not created:
                            # 이미 장바구니에 있으면 수량만 1 증가
                            cart_item.quantity += 1
                            cart_item.save()
                        
                        added_products.append(product_id)
                        
                    except Product.DoesNotExist:
                        failed_products.append({
                            "product_id": product_id,
                            "error": "상품을 찾을 수 없습니다"
                        })
                    except Exception as e:
                        failed_products.append({
                            "product_id": product_id,
                            "error": str(e)
                        })
            
            # 모든 처리가 완료된 후 응답
            if added_products:
                return Response({
                    "status": "success",
                    "message": "선택한 상품이 장바구니에 추가되었습니다",
                    "added_products": added_products,
                    "failed_products": failed_products
                }, status=status.HTTP_200_OK)
            else:
                return Response({
                    "status": "error",
                    "message": "장바구니에 추가할 수 있는 상품이 없습니다",
                    "failed_products": failed_products
                }, status=status.HTTP_400_BAD_REQUEST)
                
        except Exception as e:
            return Response({
                "status": "error",
                "message": f"장바구니 추가 중 오류가 발생했습니다: {str(e)}"
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)    

    @action(detail=False, methods=['GET'])
    def my_cart(self, request):
        """사용자의 장바구니 목록 조회"""
        try:
            # request.user 대신 self.request.user를 사용할 수도 있음
            cart_items = CartItem.objects.filter(user=request.user)
            data = []
            
            for item in cart_items:
                product_data = ProductSerializer(item.product).data
                data.append({
                    'id': item.id,
                    'product': product_data,
                    'quantity': item.quantity,
                    'total_price': float(item.product.price) * item.quantity,
                    'added_at': item.added_at
                })

            return Response(data)
        except Exception as e:
            return Response({
                'error': str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)

                    

    @action(detail=True, methods=['POST'])
    def add_to_cart(self, request, pk=None):
        """장바구니에 추가"""
        try:
            if not request.user.is_authenticated:
                return Response(
                    {'error': '로그인이 필요한 서비스입니다.'}, 
                    status=status.HTTP_401_UNAUTHORIZED
                )

            product = self.get_object()
            
            # CartItem 생성 또는 업데이트
            cart_item, created = CartItem.objects.get_or_create(
                user=request.user,
                product=product,
                defaults={'quantity': 1}
            )
            
            if not created:
                cart_item.quantity += 1
                cart_item.save()

            # UserBehavior 업데이트
            behavior, _ = UserBehavior.objects.get_or_create(
                user=request.user,
                product=product
            )
            behavior.cart_add_count += 1
            behavior.save()
            
            serializer = CartItemSerializer(cart_item)

            return Response({
                'status': 'success',
                'message': {'detail': '장바구니에 추가되었습니다.'},
                'cart_item': serializer.data
            })

        except Exception as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_400_BAD_REQUEST
            )

        
    @action(detail=True, methods=['PATCH'])  
    def update_quantity(self, request, pk=None):
        """장바구니 상품 수량 업데이트"""
        try:
            cart_item = CartItem.objects.get(
                user=request.user,
                product_id=pk
            )
            
            quantity = int(request.data.get('quantity', 1))
            
            # 재고 확인
            if cart_item.product.stock < quantity:
                return Response({
                    'error': '재고가 부족합니다.'
                }, status=status.HTTP_400_BAD_REQUEST)
                
            cart_item.quantity = quantity
            cart_item.save()
            
            return Response({
                'message': '수량이 업데이트되었습니다.',
                'quantity': cart_item.quantity
            })
            
        except CartItem.DoesNotExist:
            return Response({
                'error': '장바구니에 해당 상품이 없습니다.'
            }, status=status.HTTP_404_NOT_FOUND)
            
        except Exception as e:
            return Response({
                'error': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)


    @action(detail=True, methods=['DELETE'])
    def remove_item(self, request, pk=None):
        """장바구니에서 상품 제거"""
        try:
            result = CartItem.objects.filter(
                user=request.user,
                product_id=pk
            ).delete()
            
            if result[0] == 0:  # 삭제된 항목이 없음
                return Response({
                    'error': '장바구니에 해당 상품이 없습니다.'
                }, status=status.HTTP_404_NOT_FOUND)
                
            return Response({
                'message': '상품이 장바구니에서 제거되었습니다.'
            })
            
        except Exception as e:
            return Response({
                'error': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)


    @action(detail=False, methods=['DELETE'])
    def clear(self, request):
        """장바구니 비우기"""
        try:
            CartItem.objects.filter(user=request.user).delete()
            return Response({
                'message': '장바구니가 비워졌습니다.'
            })
        except Exception as e:
            return Response({
                'error': str(e)
            }, status=status.HTTP_400_BAD_REQUEST)
                    


    @action(detail=True, methods=['GET'])
    def check_cart_status(self, request, pk=None):
        """장바구니 상태 확인"""
        try:
            if not request.user.is_authenticated:
                return Response({'in_cart': False})

            product = self.get_object()
            in_cart = UserBehavior.objects.filter(
                user=request.user,
                product=product,
                cart_add_count__gt=0
            ).exists()

            return Response({'in_cart': in_cart})

        except Exception as e:
            print(f"장바구니 상태 확인 중 오류 발생: {str(e)}")
            return Response({'in_cart': False})
                
    # 사용자 행동을 기록하는 함수
    def record_user_behavior(user, product, view_duration=0, click=False, cart_add=False, purchase=False):
        behavior, created = UserBehavior.objects.get_or_create(
            user=user,
            product=product,
            defaults={
                'view_duration': view_duration,
                'click_count': 1 if click else 0,
                'cart_add_count': 1 if cart_add else 0,
                'purchase_count': 1 if purchase else 0,
                'last_viewed': timezone.now(),
            }
        )

        if not created:
            behavior.view_duration += view_duration
            if click:
                behavior.click_count += 1
            if cart_add:
                behavior.cart_add_count += 1
            if purchase:
                behavior.purchase_count += 1
            behavior.last_viewed = timezone.now()
            behavior.save()
                
    @action(detail=False, methods=['POST'])
    def purchase(self, request):
        try:
            user = request.user
            print(f"[DEBUG] Purchase attempt by user: {user.username}")
            if not user.is_authenticated:
                return Response(
                    {'error': '로그인이 필요한 서비스입니다.'}, 
                    status=status.HTTP_401_UNAUTHORIZED
                )

            with transaction.atomic():
                # 장바구니 아이템 조회
                cart_items = CartItem.objects.filter(user=user)
                print(f"[DEBUG] Cart items found: {cart_items.count()}")
                            
                if not cart_items.exists():
                    return Response(
                        {'error': '장바구니가 비어있습니다.'}, 
                        status=status.HTTP_400_BAD_REQUEST
                    )

                # 총 구매 금액 계산
                total_amount = Decimal('0')
                for item in cart_items:
                    print(f"[DEBUG] Processing item: {item.product.title}, Quantity: {item.quantity}, Price: {item.product.price}")
                    total_amount += item.product.price * Decimal(str(item.quantity))

                # 사용자 마일리지 조회
                profile = user.userprofile
                if profile.mileage < total_amount:
                    return Response(
                        {'error': f'마일리지가 부족합니다. (보유: {profile.mileage:,}원, 필요: {total_amount:,}원)'}, 
                        status=status.HTTP_400_BAD_REQUEST
                    )

                # 마일리지 차감
                profile.mileage -= total_amount
                profile.save()

                # 구매 기록 생성 및 재고 체크/감소
                for item in cart_items:
                    # 재고 확인
                    if item.product.stock < item.quantity:
                        raise ValueError(f'{item.product.title}의 재고가 부족합니다.')
                    
                    # 재고 감소
                    item.product.stock -= item.quantity
                    item.product.save()
                    
                    # 구매 기록 생성 또는 업데이트
                    behavior, created = UserBehavior.objects.get_or_create(
                        user=user,
                        product=item.product,
                        defaults={
                            'purchase_count': item.quantity,
                            'view_duration': 0,
                            'click_count': 0,
                            'cart_add_count': 0,
                            'favorite_count': 0,
                            'review_score': 0,
                            'last_viewed': timezone.now()
                        }
                    )
                    
                    if not created:
                        behavior.purchase_count += item.quantity
                        behavior.save()

                # 장바구니 비우기
                cart_items.delete()

                return Response({
                    'message': '구매가 완료되었습니다.',
                    'total_amount': total_amount,
                    'remaining_mileage': profile.mileage
                })

        except ValueError as e:
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_400_BAD_REQUEST
            )
        except Exception as e:
            print(f"[ERROR] Purchase failed: {str(e)}")
            print(f"[ERROR] Error type: {type(e)}")
            import traceback
            print(traceback.format_exc())
            print(f"Purchase error: {str(e)}")
            return Response(
                {'error': str(e)}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
            
class StandardResultsSetPagination(PageNumberPagination):
    page_size = 50
    page_size_query_param = 'page_size'
    max_page_size = 100

class ViewedProductsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        try:
            page = int(request.query_params.get('page', 1))
            page_size = int(request.query_params.get('page_size', 12))
            offset = (page - 1) * page_size

            user = request.user
            products = Product.objects.filter(
                Q(productview__user=user) | 
                Q(userbehavior__user=user, userbehavior__view_duration__gt=0)
            ).annotate(
                latest_view=Max('productview__viewed_at')
            ).order_by('-latest_view').distinct()

            total_products = products.count()
            paginated_products = products[offset:offset + page_size]
            
            return Response({
                'results': ProductSerializer(paginated_products, many=True).data,
                'next': (offset + page_size) < total_products
            })

        except Exception as e:
            print(f"Error in ViewedProductsView: {str(e)}")
            return Response(
                {'error': 'Internal server error'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )

class FavoriteProductsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        try:
            page = int(request.query_params.get('page', 1))
            page_size = int(request.query_params.get('page_size', 12))
            offset = (page - 1) * page_size

            user = request.user
            products = Product.objects.filter(
                productfavorite__user=user
            ).order_by('-productfavorite__created_at')

            total_products = products.count()
            paginated_products = products[offset:offset + page_size]
            
            return Response({
                'results': ProductSerializer(paginated_products, many=True).data,
                'next': (offset + page_size) < total_products
            })

        except Exception as e:
            print(f"Error in FavoriteProductsView: {str(e)}")
            return Response(
                {'error': 'Internal server error'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )


class UserReviewsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        try:
            page = int(request.query_params.get('page', 1))
            page_size = int(request.query_params.get('page_size', 12))
            offset = (page - 1) * page_size

            user = request.user
            reviews = UserProductRating.objects.filter(
                user=user
            ).select_related('product', 'user').order_by('-created_at')

            print(f"Found {reviews.count()} reviews for user {user}")  # 디버깅용 로그 추가

            total_reviews = reviews.count()
            paginated_reviews = reviews[offset:offset + page_size]

            serialized_data = [
                {
                    'id': review.id,
                    'rating': review.rating,
                    'content': review.content,
                    'created_at': review.created_at,
                    'product': ProductSerializer(review.product).data
                } for review in paginated_reviews
            ]

            return Response({
                'results': serialized_data,
                'next': (offset + page_size) < total_reviews
            })
            
        except Exception as e:
            print(f"Error in UserReviewsView: {str(e)}")
            print(f"Error details: {type(e).__name__}")  # 에러 타입 추가
            import traceback
            print(traceback.format_exc())  # 스택 트레이스 추가
            return Response(
                {'error': f'Internal server error: {str(e)}'}, 
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )



    
    
def create_paginated_response(queryset, page, page_size, serializer_class):

    offset = (page - 1) * page_size
    total_count = queryset.count()
    items = queryset[offset:offset + page_size]

    return {
        'count': total_count,
        'next': (offset + page_size) < total_count,
        'previous': page > 1,
        'results': serializer_class(items, many=True).data
    }=== backend/products/ml_models.py ===
# backend/products/ml_models.py
import torch
import torch.nn as nn
import torch.nn.functional as F

class ProductRecommender(nn.Module):
    def __init__(self, n_users, n_products, embedding_dim=50):
        super().__init__()
        
        # 임베딩 레이어
        self.user_embedding = nn.Embedding(n_users, embedding_dim)
        self.product_embedding = nn.Embedding(n_products, embedding_dim)
        
        # 사용자 특성 처리를 위한 레이어
        self.user_features = nn.Sequential(
            nn.Linear(11, 32),  # 성별(3) + 연령대(5) + 소득수준(3) = 11
            nn.ReLU(),
            nn.Dropout(0.2)
        )
        
        # 행동 데이터 처리를 위한 레이어
        self.behavior_features = nn.Sequential(
            nn.Linear(3, 32),  # 클릭수 + 체류시간 + 장바구니추가수
            nn.ReLU(),
            nn.Dropout(0.2)
        )
        
        # 최종 예측 레이어
        self.predictor = nn.Sequential(
            nn.Linear(embedding_dim + 64, 32),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(32, 1),
            nn.Sigmoid()
        )
    
    def forward(self, user_ids, product_ids, user_features, behavior_data):
        # 임베딩
        user_embeds = self.user_embedding(user_ids)
        product_embeds = self.product_embedding(product_ids)
        
        # 특성 처리
        user_feat = self.user_features(user_features)
        behavior_feat = self.behavior_features(behavior_data)
        
        # 모든 특성 결합
        combined = torch.cat([
            user_embeds * product_embeds,
            user_feat,
            behavior_feat
        ], dim=1)
        
        # 최종 예측
        return self.predictor(combined)
=== backend/config/asgi.py ===
# backend/config/asgi.py
"""
ASGI config for config project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_asgi_application()
=== backend/config/__init__.py ===
=== backend/config/settings.py ===
"""
Django settings for config project.

Generated by 'django-admin startproject' using Django 5.1.3.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.1/ref/settings/
"""

from pathlib import Path
import os



# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-p4r_)i8tqo(438_a)am8f7v2y)_&&+vtac0f7ofykr!9vp(637'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = ['*'] 

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'corsheaders',
    'products',
    'django_filters',
    'accounts',
    'imagekit',
    'django_extensions',
    ]

MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
]

CORS_ALLOW_CREDENTIALS = True

CSRF_TRUSTED_ORIGINS = [
    "http://localhost:3000",
] 

CSRF_COOKIE_SAMESITE = 'Lax'
SESSION_COOKIE_SAMESITE = 'Lax'
CSRF_COOKIE_HTTPONLY = False  # JavaScript에서 접근 가능하게
SESSION_COOKIE_HTTPONLY = True
CSRF_USE_SESSIONS = False
CSRF_TRUSTED_ORIGINS = ['http://localhost:3000']

REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny',
    ],    
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
    ],
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend',
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10
}

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'ecommerce_db',
        'USER': 'ecommerce_user',
        'PASSWORD': '1234',
        'HOST': 'localhost',  # 'db' 대신 'localhost' 사용
        'PORT': '5432',
    }
}



# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Media files (Uploaded files)
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Static files
STATIC_URL = 'static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')=== backend/config/urls.py ===
# backend/config/urls.py
from django.contrib import admin
from django.urls import path, include
from django.conf import settings
from django.conf.urls.static import static
from rest_framework.routers import DefaultRouter


router = DefaultRouter()

urlpatterns = [
    path('', include(router.urls)),
    path('admin/', admin.site.urls),
    path('api/', include('products.urls')),
    path('api/accounts/', include('accounts.urls')),  # accounts 앱 URL    
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
=== backend/config/wsgi.py ===
"""
WSGI config for config project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.1/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')

application = get_wsgi_application()
=== backend/temp_settings.py ===
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'ecommerce_db',
        'USER': 'ecommerce_user',
        'PASSWORD': '1234',
        'HOST': 'db',
        'PORT': '5432',
    }
}
=== backend/accounts/signals.py ===
# accounts/signals.py
from django.db.models.signals import post_save
from django.contrib.auth.models import User
from django.dispatch import receiver
from .models import UserProfile

@receiver(post_save, sender=User)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        UserProfile.objects.create(
            user=instance,
            gender='O',  # 기본값
            age_group='20',  # 기본값
            income_level='M'  # 기본값
        )

@receiver(post_save, sender=User)
def save_user_profile(sender, instance, **kwargs):
    if not hasattr(instance, 'userprofile'):
        UserProfile.objects.create(
            user=instance,
            gender='O',
            age_group='20',
            income_level='M'
        )
    instance.userprofile.save()=== backend/accounts/models.py ===
from django.db.models import Sum, F, ExpressionWrapper, FloatField, Q
from products.models import ( UserBehavior, ProductView, UserProductRating, ProductFavorite)
from django.apps import apps
from django.db import models
from django.contrib.auth.models import User
from django.db.models import FloatField
from django.db.models.functions import Cast
from django.utils import timezone  # timezone import 추가
from datetime import timedelta  # timedelta import 추가


class UserProfile(models.Model):
    GENDER_CHOICES = (
        ('M', '남성'),
        ('F', '여성'),
        ('O', '기타'),
    )

    AGE_GROUP_CHOICES = (
        ('10', '10대'),
        ('20', '20대'),
        ('30', '30대'),
        ('40', '40대'),
        ('50', '50대 이상'),
    )

    INCOME_LEVEL_CHOICES = (
        ('L', '저소득'),
        ('M', '중소득'),
        ('H', '고소득'),
    )

    user = models.OneToOneField(User, on_delete=models.CASCADE)
    gender = models.CharField(max_length=1, choices=GENDER_CHOICES)
    age_group = models.CharField(max_length=2, choices=AGE_GROUP_CHOICES)
    income_level = models.CharField(max_length=1, choices=INCOME_LEVEL_CHOICES)
    mileage = models.DecimalField(max_digits=12, decimal_places=2, default=10000000)  # 1000만원 기본값
    preferred_categories = models.ManyToManyField('products.ProductCategory', blank=True)  # 문자열로 참조
    dummy_field = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.user.username}'s profile"
    
    def get_activity_stats(self):
        """사용자 활동 통계 반환"""

        # 조회수 계산
        total_views = ProductView.objects.filter(user=self.user).count()

        # 찜한 상품 수
        favorite_count = ProductFavorite.objects.filter(user=self.user).count()

        # 장바구니에 담은 상품 수
        cart_count = UserBehavior.objects.filter(
            user=self.user,
            cart_add_count__gt=0
        ).count()

        # 리뷰 수
        review_count = UserProductRating.objects.filter(user=self.user).count()

        return {
            'total_views': total_views,
            'favorite_count': favorite_count,
            'cart_count': cart_count,
            'review_count': review_count
        }
    


    def update_preferred_categories(self):
        """사용자의 행동 데이터를 기반으로 선호 카테고리 업데이트"""
        try:
            print(f"\nUpdating preferences for user: {self.user.username}")
            
            thirty_days_ago = timezone.now() - timedelta(days=30)
            
            category_scores = UserBehavior.objects.filter(
                user=self.user,
                product__category__isnull=False,
                last_viewed__gte=thirty_days_ago
            ).values(
                'product__category',
                'product__category__name'
            ).annotate(
                view_score=ExpressionWrapper(
                    Cast(Sum('view_duration'), FloatField()) * 0.3,
                    output_field=FloatField()
                ),
                click_score=ExpressionWrapper(
                    Cast(Sum('click_count'), FloatField()) * 0.5,
                    output_field=FloatField()
                ),
                cart_score=ExpressionWrapper(
                    Cast(Sum('cart_add_count'), FloatField()) * 1.5,  # 장바구니 가중치 증가
                    output_field=FloatField()
                ),
                purchase_score=ExpressionWrapper(
                    Cast(Sum('purchase_count'), FloatField()) * 2.0,
                    output_field=FloatField()
                ),
                total_score=ExpressionWrapper(
                    Cast(Sum('view_duration'), FloatField()) * 0.3 +
                    Cast(Sum('click_count'), FloatField()) * 0.5 +
                    Cast(Sum('cart_add_count'), FloatField()) * 1.5 +  # 장바구니 가중치 증가
                    Cast(Sum('purchase_count'), FloatField()) * 2.0,
                    Cast(Sum('favorite_count'), FloatField()) * 1.0 +  # 찜하기 점수
                    Cast(Sum('review_score'), FloatField()) * 1.0,    # 리뷰 점수

                    output_field=FloatField()
                )
            ).order_by('-total_score')

            print("\nCategory scores calculated:")
            for score in category_scores:
                print(f"Category: {score['product__category__name']}")
                print(f"- View Score: {score.get('view_score', 0):.2f}")
                print(f"- Click Score: {score.get('click_score', 0):.2f}")
                print(f"- Cart Score: {score.get('cart_score', 0):.2f}")
                print(f"- Purchase Score: {score.get('purchase_score', 0):.2f}")
                print(f"- Total Score: {score.get('total_score', 0):.2f}")

            # 기존 선호도 제거
            self.preferred_categories.clear()

            # 상위 5개 카테고리 선정 및 추가
            ProductCategory = apps.get_model('products', 'ProductCategory')
            for score in category_scores[:5]:
                if score['product__category'] is not None:
                    try:
                        category = ProductCategory.objects.get(id=score['product__category'])
                        self.preferred_categories.add(category)
                        print(f"Added preferred category: {category.name} (Score: {score.get('total_score', 0):.2f})")
                    except ProductCategory.DoesNotExist:
                        print(f"Category {score['product__category']} not found")

            print("\nPreference update completed successfully")
            return True

        except Exception as e:
            print(f"Error updating preferences: {str(e)}")
            import traceback
            print(traceback.format_exc())
            return False
=== backend/accounts/management/commands/create_user_profiles.py ===
# backend/accounts/management/commands/create_user_profiles.py
from django.core.management.base import BaseCommand
from django.contrib.auth.models import User
from accounts.models import UserProfile
from products.models import ProductCategory

class Command(BaseCommand):
    help = '기존 사용자들을 위한 프로필 생성'

    def handle(self, *args, **kwargs):
        users = User.objects.all()
        created_count = 0
        
        # 카테고리 딕셔너리 생성
        categories = {
            'male': {
                'L': ['전자기기', '도서'],
                'M': ['전자기기', '스포츠/레저'],
                'H': ['전자기기', '스포츠/레저', '패션잡화']
            },
            'female': {
                'L': ['화장품', '문구/취미'],
                'M': ['패션잡화', '화장품'],
                'H': ['패션잡화', '화장품', '전자기기']
            }
        }
        
        for user in users:
            try:
                if not hasattr(user, 'userprofile'):
                    # 사용자명에서 정보 추출 (예: male_20_low)
                    parts = user.username.split('_')
                    if len(parts) == 3:
                        gender = 'M' if parts[0] == 'male' else 'F'
                        age_group = parts[1]
                        income_level = 'L' if parts[2] == 'low' else ('H' if parts[2] == 'high' else 'M')
                        
                        # 프로필 생성
                        profile = UserProfile.objects.create(
                            user=user,
                            gender=gender,
                            age_group=age_group,
                            income_level=income_level
                        )
                        
                        # 선호 카테고리 설정
                        gender_key = 'male' if gender == 'M' else 'female'
                        preferred_category_names = categories[gender_key][income_level]
                        preferred_categories = ProductCategory.objects.filter(
                            name__in=preferred_category_names
                        )
                        profile.preferred_categories.add(*preferred_categories)
                        
                        # 실제 행동 데이터 기반으로 선호도 업데이트
                        profile.update_preferred_categories()
                        
                        created_count += 1
                        self.stdout.write(f'Created profile for {user.username}')
            except Exception as e:
                self.stdout.write(self.style.ERROR(f'Error creating profile for {user.username}: {str(e)}'))
        
        self.stdout.write(self.style.SUCCESS(f'{created_count}개의 프로필이 생성되었습니다.'))
=== backend/accounts/__init__.py ===
=== backend/accounts/apps.py ===
# accounts/apps.py
from django.apps import AppConfig

class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

    def ready(self):
        import accounts.signals  # signals 등록=== backend/accounts/admin.py ===
# backend/accounts/admin.py
from django.contrib import admin
from .models import UserProfile

@admin.register(UserProfile)
class UserProfileAdmin(admin.ModelAdmin):
    list_display = ['user', 'gender', 'age_group', 'income_level']
=== backend/accounts/tests.py ===
# backend/accounts/tests.py
from django.test import TestCase

# Create your tests here.
=== backend/accounts/urls.py ===
# backend/accounts/urls.py
from django.urls import path
from . import views

app_name = 'accounts'

urlpatterns = [
    path('login/', views.LoginView.as_view()),
    path('logout/', views.LogoutView.as_view()),
    path('signup/', views.SignupView.as_view()),
    path('check-login/', views.CheckLoginStatusView.as_view()),
    path('csrf/', views.GetCSRFToken.as_view()),
    path('profile/', views.UserProfileView.as_view()),
    path('analytics/', views.UserAnalyticsView.as_view()),
]=== backend/accounts/views.py ===
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.models import User
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from rest_framework.permissions import IsAuthenticated
from rest_framework.authentication import SessionAuthentication
from rest_framework.decorators import api_view
from django.views.decorators.csrf import ensure_csrf_cookie
from django.utils.decorators import method_decorator
from products.models import (
    ProductCategory, ProductFavorite, ProductView, RecommendationLog,
    UserProductRating, Product, UserBehavior, CartItem
)
from django.db.models import Count, Sum, Avg, F, ExpressionWrapper, FloatField, Q, Max, Case, When
from django.db.models.functions import Coalesce, Cast, Greatest, ExtractHour, ExtractMonth, TruncMonth
from django.core.exceptions import ObjectDoesNotExist
from .models import UserProfile
from products.serializers import ProductSerializer, ReviewSerializer
from rest_framework.pagination import PageNumberPagination
from django.utils import timezone
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo
import json

@method_decorator(ensure_csrf_cookie, name='dispatch')
class LoginView(APIView):
    authentication_classes = []
    permission_classes = []

    def post(self, request):
        username = request.data.get('username')
        password = request.data.get('password')
        user = authenticate(username=username, password=password)

        if user is not None:
            login(request, user)
            try:
                profile = user.userprofile
                user_data = {
                    'username': user.username,
                    'gender': profile.gender,
                    'age_group': profile.age_group,
                    'income_level': profile.income_level
                }
            except UserProfile.DoesNotExist:
                user_data = {'username': user.username}
            return Response({'status': 'success', 'user': user_data})
        return Response({'status': 'error', 'message': '로그인에 실패했습니다.'}, status=status.HTTP_400_BAD_REQUEST)

@method_decorator(ensure_csrf_cookie, name='dispatch')
class LogoutView(APIView):
    @method_decorator(ensure_csrf_cookie)
    def post(self, request):
        if request.user.is_authenticated:
            logout(request)
            return Response({'status': 'success', 'message': '로그아웃되었습니다.'})
        return Response({'status': 'error', 'message': '로그인 상태가 아닙니다.'}, status=status.HTTP_400_BAD_REQUEST)

class CheckLoginStatusView(APIView):
    authentication_classes = [SessionAuthentication]
    permission_classes = []  # 권한 체크 해제

    def get(self, request):
        if request.user.is_authenticated:
            try:
                profile = request.user.userprofile
                user_data = {
                    'username': request.user.username,
                    'gender': profile.gender,
                    'age_group': profile.age_group,
                    'mileage': profile.mileage
                }
            except UserProfile.DoesNotExist:
                user_data = {
                    'username': request.user.username
                }
            return Response({
                'isAuthenticated': True,
                'user': user_data
            })
        return Response({
            'isAuthenticated': False,
            'user': None
        })
        
@method_decorator(ensure_csrf_cookie, name='dispatch')
class SignupView(APIView):
    authentication_classes = []
    permission_classes = []

    def post(self, request):
        username = request.data.get('username')
        password = request.data.get('password')
        gender = request.data.get('gender')
        age_group = request.data.get('age_group')
        income_level = request.data.get('income_level')

        if not username or not password:
            return Response({'status': 'error', 'message': '사용자명과 비밀번호는 필수입니다.'}, status=status.HTTP_400_BAD_REQUEST)

        if User.objects.filter(username=username).exists():
            return Response({'status': 'error', 'message': '이미 존재하는 사용자명입니다.'}, status=status.HTTP_400_BAD_REQUEST)

        user = User.objects.create_user(username=username, password=password)
        user.save()

        UserProfile.objects.create(user=user, gender=gender, age_group=age_group, income_level=income_level)

        return Response({'status': 'success', 'message': '회원가입이 완료되었습니다.', 'user': {'username': username}})


class UserProfileView(APIView):
    authentication_classes = [SessionAuthentication]
    permission_classes = []

    def get(self, request):
        try:
            if not request.user.is_authenticated:
                return Response({
                    'user': None,
                    'is_authenticated': False,
                    'activity_stats': {
                        'total_views': 0,
                        'favorite_count': 0,
                        'cart_count': 0,
                        'review_count': 0
                    },
                    'category_preferences': []
                })

            user = request.user
            profile = user.userprofile

            # UserProfile에서 mileage 필드 사용
            user_data = {
                'username': user.username,
                'gender': profile.gender,
                'age_group': profile.age_group,
                'income_level': profile.income_level,
                'mileage': profile.mileage,
            }

            # 사용자 활동 통계 계산
            activity_stats = {
                'total_views': ProductView.objects.filter(user=user).count(),
                'favorite_count': ProductFavorite.objects.filter(user=user).count(),
                'cart_count': CartItem.objects.filter(user=user).count(),
                'review_count': UserProductRating.objects.filter(user=user).count()
            }

            # 카테고리 선호도 계산
            categories = ProductCategory.objects.all()
            category_preferences = []
            total_score = 0

            # 첫 번째 패스: 모든 카테고리의 점수 합계 계산
            for category in categories:
                behavior_data = UserBehavior.objects.filter(user=user, product__category=category).aggregate(
                    view_duration=Coalesce(Cast(Sum('view_duration'), FloatField()), 0.0),
                    clicks=Coalesce(Cast(Sum('click_count'), FloatField()), 0.0),
                    cart_adds=Coalesce(Cast(Sum('cart_add_count'), FloatField()), 0.0),
                    purchases=Coalesce(Cast(Sum('purchase_count'), FloatField()), 0.0)
                )
                
                behavior_score = (
                    float(behavior_data['view_duration']) * 0.3 +
                    float(behavior_data['clicks']) * 0.5 +
                    float(behavior_data['cart_adds']) * 1.0 +
                    float(behavior_data['purchases']) * 2.0
                )
                
                view_score = float(ProductView.objects.filter(user=user, product__category=category).aggregate(
                    total_duration=Coalesce(Cast(Sum('view_duration'), FloatField()), 0.0)
                )['total_duration'])
                
                rec_score = float(RecommendationLog.objects.filter(
                    user=user, product__category=category, clicked=True
                ).aggregate(
                    avg_score=Coalesce(Cast(Avg('score'), FloatField()), 0.0)
                )['avg_score'])
                
                rating_score = float(UserProductRating.objects.filter(
                    user=user, product__category=category
                ).aggregate(
                    avg_rating=Coalesce(Cast(Avg('rating'), FloatField()), 0.0)
                )['avg_rating'])

                total_category_score = (
                    behavior_score * 0.4 +
                    view_score * 0.2 +
                    rec_score * 0.2 +
                    rating_score * 0.2
                )

                if total_category_score > 0:
                    category_preferences.append({
                        'name': category.name,
                        'total_score': total_category_score
                    })
                    total_score += total_category_score

            # 두 번째 패스: 백분율 계산
            normalized_preferences = []
            if total_score > 0:
                for pref in category_preferences:
                    percentage = (pref['total_score'] / total_score) * 100
                    normalized_preferences.append({
                        'category': pref['name'],
                        'score': round(percentage, 1)
                    })
            
            # 점수 기준 내림차순 정렬
            normalized_preferences.sort(key=lambda x: x['score'], reverse=True)

            return Response({
                'user': user_data,
                'is_authenticated': True,
                'category_preferences': normalized_preferences,
                'activity_stats': activity_stats
            })

        except UserProfile.DoesNotExist:
            return Response({'error': '사용자 프로필을 찾을 수 없습니다.'}, status=status.HTTP_404_NOT_FOUND)
        except Exception as e:
            print(f"Profile view error: {str(e)}")
            return Response({'error': '사용자 데이터를 불러오는 중 오류가 발생했습니다.', 'is_authenticated': False}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
class UserAnalyticsView(APIView):
    permission_classes = [IsAuthenticated]
    
    def get(self, request):
        user = request.user
        end_date = timezone.now()
        start_date = end_date - timedelta(days=30)  # 최근 30일 데이터
        
        # 시간대별 쇼핑 패턴
        time_patterns = (
            ProductView.objects.filter(
                user=user,
                viewed_at__range=(start_date, end_date)
            ).extra(
                select={'hour': "EXTRACT(hour FROM viewed_at)"}
            ).values('hour').annotate(
                views=Count('id')
            ).order_by('hour')
        )

        # 상호작용 통계
        interaction_stats = {
            'views': ProductView.objects.filter(user=user).count(),
            'purchases': UserBehavior.objects.filter(
                user=user, purchase_count__gt=0
            ).count(),
            'cart_adds': UserBehavior.objects.filter(
                user=user, cart_add_count__gt=0
            ).count(),
        }

        # 카테고리별 평점 분석
        rating_analysis = (
            UserProductRating.objects.filter(user=user)
            .values('product__category__name')
            .annotate(
                avg_rating=Avg('rating'),
                review_count=Count('id')
            )
        )

        # 구매 패턴 (월별)
        purchase_patterns = (
            UserBehavior.objects.filter(
                user=user,
                purchase_count__gt=0
            ).extra(
                select={'month': "EXTRACT(month FROM last_viewed)"}
            ).values('month').annotate(
                amount=Count('id')
            ).order_by('month')
        )

        return Response({
            'timePatterns': list(time_patterns),
            'interactionStats': [
                {'name': key, 'value': value}
                for key, value in interaction_stats.items()
            ],
            'ratingAnalysis': list(rating_analysis),
            'purchasePatterns': list(purchase_patterns)
        })

@method_decorator(ensure_csrf_cookie, name='dispatch')
class GetCSRFToken(APIView):
    permission_classes = []

    def get(self, request):
        return Response({'detail': 'CSRF cookie set'})
=== backend/manage.py ===
# manage.py
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django."
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
